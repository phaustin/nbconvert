#!/usr/bin/env python
"""Convert IPython notebooks to other formats, such as ReST, and HTML.

Example:
  ./nbconvert.py --format rst file.ipynb

Produces 'file.rst', along with auto-generated figure files
called nb_figure_NN.png.
"""
#-----------------------------------------------------------------------------
# Imports
#-----------------------------------------------------------------------------
from __future__ import print_function

# Stdlib
import codecs
import io
import logging
import os
import pprint
import re
import subprocess
import sys
import json
import copy
from shutil import rmtree
from markdown import markdown

inkscape = 'inkscape'
if sys.platform == 'darwin':
    inkscape = '/Applications/Inkscape.app/Contents/Resources/bin/inkscape'
    if not os.path.exists(inkscape):
        inkscape = None

# From IPython
from IPython.external import argparse
from IPython.nbformat import current as nbformat
from IPython.utils.text import indent
from IPython.nbformat.v3.nbjson import BytesEncoder
from IPython.utils import path, py3compat

# local
from decorators import DocInherit
from lexers import IPythonLexer


#-----------------------------------------------------------------------------
# Utility functions
#-----------------------------------------------------------------------------

def DocInherit(f):
    return f

def remove_fake_files_url(cell):
    """Remove from the cell source the /files/ pseudo-path we use.
    """
    src = cell.source
    cell.source = src.replace('/files/', '')


# ANSI color functions:

def remove_ansi(src):
    """Strip all ANSI color escape sequences from input string.

    Parameters
    ----------
    src : string

    Returns
    -------
    string
    """
    return re.sub(r'\033\[(0|\d;\d\d)m', '', src)


def ansi2html(txt):
    """Render ANSI colors as HTML colors
    
    This is equivalent to util.fixConsole in utils.js
    
    Parameters
    ----------
    txt : string

    Returns
    -------
    string
    """
    
    ansi_colormap = {
        '30': 'ansiblack',
        '31': 'ansired',
        '32': 'ansigreen',
        '33': 'ansiyellow',
        '34': 'ansiblue',
        '35': 'ansipurple',
        '36': 'ansicyan',
        '37': 'ansigrey',
        '01': 'ansibold',
    }
    
    # do ampersand first
    txt = txt.replace('&', '&amp;')
    html_escapes = {
        '<': '&lt;',
        '>': '&gt;',
        "'": '&apos;',
        '"': '&quot;',
        '`': '&#96;',
    }
    for c, escape in html_escapes.iteritems():
        txt = txt.replace(c, escape)
    
    ansi_re = re.compile('\x1b' + r'\[([\dA-Fa-f;]*?)m')
    m = ansi_re.search(txt)
    opened = False
    cmds = []
    opener = ''
    closer = ''
    while m:
        cmds = m.groups()[0].split(';')
        closer = '</span>' if opened else ''
        opened = len(cmds) > 1 or cmds[0] != '0'*len(cmds[0]);
        classes = []
        for cmd in cmds:
            if cmd in ansi_colormap:
                classes.append(ansi_colormap.get(cmd))
        
        if classes:
            opener = '<span class="%s">' % (' '.join(classes))
        else:
            opener = ''
        txt = re.sub(ansi_re, closer + opener, txt, 1)
        
        m = ansi_re.search(txt)
    
    if opened:
        txt += '</span>'
    return txt


# Pandoc-dependent code

def markdown2latex(src):
    """Convert a markdown string to LaTeX via pandoc.

    This function will raise an error if pandoc is not installed.

    Any error messages generated by pandoc are printed to stderr.

    Parameters
    ----------
    src : string
      Input string, assumed to be valid markdown.

    Returns
    -------
    out : string
      Output as returned by pandoc.
    """
    p = subprocess.Popen('pandoc -f markdown -t latex'.split(),
                         stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    out, err = p.communicate(src.encode('utf-8'))
    if err:
        print(err, file=sys.stderr)
    #print('*'*20+'\n', out, '\n'+'*'*20)  # dbg
    return unicode(out,'utf-8')


def markdown2rst(src):
    """Convert a markdown string to LaTeX via pandoc.

    This function will raise an error if pandoc is not installed.

    Any error messages generated by pandoc are printed to stderr.

    Parameters
    ----------
    src : string
      Input string, assumed to be valid markdown.

    Returns
    -------
    out : string
      Output as returned by pandoc.
    """
    p = subprocess.Popen('pandoc -f markdown -t rst'.split(),
                         stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    out, err = p.communicate(src.encode('utf-8'))
    if err:
        print(err, file=sys.stderr)
    #print('*'*20+'\n', out, '\n'+'*'*20)  # dbg
    return unicode(out,'utf-8')


def rst_directive(directive, text=''):
    out = [directive, '']
    if text:
        out.extend([indent(text), ''])
    return out


def coalesce_streams(outputs):
    """merge consecutive sequences of stream output into single stream
    
    to prevent extra newlines inserted at flush calls
    
    TODO: handle \r deletion
    """
    new_outputs = []
    last = outputs[0]
    new_outputs = [last]
    for output in outputs[1:]:
        if (output.output_type == 'stream' and
            last.output_type == 'stream' and
            last.stream == output.stream
        ):
            last.text += output.text
        else:
            new_outputs.append(output)
    
    return new_outputs


#-----------------------------------------------------------------------------
# Class declarations
#-----------------------------------------------------------------------------



#-----------------------------------------------------------------------------
# Standalone conversion functions
#-----------------------------------------------------------------------------

def rst2simplehtml(infile):
    """Convert a rst file to simplified html suitable for blogger.

    This just runs rst2html with certain parameters to produce really simple
    html and strips the document header, so the resulting file can be easily
    pasted into a blogger edit window.
    """

    # This is the template for the rst2html call that produces the cleanest,
    # simplest html I could find.  This should help in making it easier to
    # paste into the blogspot html window, though I'm still having problems
    # with linebreaks there...
    cmd_template = ("rst2html --link-stylesheet --no-xml-declaration "
                    "--no-generator --no-datestamp --no-source-link "
                    "--no-toc-backlinks --no-section-numbering "
                    "--strip-comments ")

    cmd = "%s %s" % (cmd_template, infile)
    proc = subprocess.Popen(cmd,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            shell=True)
    html, stderr = proc.communicate()
    if stderr:
        raise IOError(stderr)

    # Make an iterator so breaking out holds state.  Our implementation of
    # searching for the html body below is basically a trivial little state
    # machine, so we need this.
    walker = iter(html.splitlines())

    # Find start of main text, break out to then print until we find end /div.
    # This may only work if there's a real title defined so we get a 'div class'
    # tag, I haven't really tried.
    for line in walker:
        if line.startswith('<body>'):
            break

    newfname = os.path.splitext(infile)[0] + '.html'
    with open(newfname, 'w') as f:
        for line in walker:
            if line.startswith('</body>'):
                break
            f.write(line)
            f.write('\n')

    return newfname


def md2html(infile):
    """Convert a markdown file to simplified html suitable for blogger.

    """
    html = markdown(open(infile).read())

    from pygments.formatters import HtmlFormatter
    css = HtmlFormatter().get_style_defs('.highlight')

    template = """
<!DOCTYPE HTML>
<html>

<head>
    <title>{infile}</title>
    <style type="text/css">
    {css}
    </style>
    
</head>
    
<body>
{html}
</body>

</html>
    """
    full_html = template.format(**locals())
    newfname = os.path.splitext(infile)[0] + '.html'
    with open(newfname, 'w') as f:
        f.write(full_html)

    return newfname

#-----------------------------------------------------------------------------
# Cell-level functions -- similar to IPython.nbformat.v3.rwbase functions
# but at cell level instead of whole notebook level
#-----------------------------------------------------------------------------

def writes_cell(cell, **kwargs):
    kwargs['cls'] = BytesEncoder
    kwargs['indent'] = 3
    kwargs['sort_keys'] = True
    kwargs['separators'] = (',',': ')
    if kwargs.pop('split_lines', True):
        cell = split_lines_cell(copy.deepcopy(cell))
    return py3compat.str_to_unicode(json.dumps(cell, **kwargs), 'utf-8')


_multiline_outputs = ['text', 'html', 'svg', 'latex', 'javascript', 'json']


def split_lines_cell(cell):
    """
    Split lines within a cell as in 
    IPython.nbformat.v3.rwbase.split_lines

    """
    if cell.cell_type == 'code':
        if 'input' in cell and isinstance(cell.input, basestring):
            cell.input = (cell.input + '\n').splitlines()
        for output in cell.outputs:
            for key in _multiline_outputs:
                item = output.get(key, None)
                if isinstance(item, basestring):
                    output[key] = (item + '\n').splitlines()
    else: # text, heading cell
        for key in ['source', 'rendered']:
            item = cell.get(key, None)
            if isinstance(item, basestring):
                cell[key] = (item + '\n').splitlines()
    return cell


def cell_to_lines(cell):
    '''
    Write a cell to json, returning the split lines.
    '''
    split_lines_cell(cell)
    s = writes_cell(cell).strip()
    return s.split('\n')


known_formats = "rst (default), html, quick-html, latex, markdown, py"

def main(infile, format='rst'):
    """Convert a notebook to html in one step"""
    # XXX: this is just quick and dirty for now. When adding a new format,
    # make sure to add it to the `known_formats` string above, which gets
    # printed in in the catch-all else, as well as in the help
    if format == 'rst':
        converter = ConverterRST(infile)
        converter.render()
    elif format == 'markdown':
        converter = ConverterMarkdown(infile)
        converter.render()
    elif format == 'html':
        converter = ConverterHTML(infile)
        htmlfname = converter.render()
    elif format == 'latex':
        converter = ConverterLaTeX(infile)
        latexfname = converter.render()
    elif format == 'py':
        converter = ConverterPy(infile)
        converter.render()
    else:
        raise SystemExit("Unknown format '%s', " % format +
                "known formats are: " + known_formats)

#-----------------------------------------------------------------------------
# Script main
#-----------------------------------------------------------------------------

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=__doc__,
            formatter_class=argparse.RawTextHelpFormatter)
    # TODO: consider passing file like object around, rather than filenames
    # would allow us to process stdin, or even http streams
    #parser.add_argument('infile', nargs='?', type=argparse.FileType('r'), default=sys.stdin)

    #Require a filename as a positional argument
    parser.add_argument('infile', nargs=1)
    parser.add_argument('-f', '--format', default='rst',
                        help='Output format. Supported formats: \n' +
                        known_formats)
    args = parser.parse_args()
    main(infile=args.infile[0], format=args.format)
